<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=index,viewport-fit=cover">
    <title>Step 5 - Naive Solver</title>
    <script type="text/javascript" src="./threejs/three.js"></script>
    <script type="text/javascript" src="./threejs/controls/OrbitControls.js"></script>
    <link rel="stylesheet" href="./reset.import.css">
    <style type="text/css">
        div#canvas-frame {
            cursor: pointer;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        .btn-list {
            list-style-type: none;
            margin: 0;
            padding: 0;
            position: fixed;
            top: 0;
            left: 0;
        }

        button {
            font-size: 20px;
            margin: 10px 0 0 10px;
            border: 1px solid #d1d1d1;
            background-color: #fff;
        }

        p {
            color: #ff0000;
            margin: 5px 0 0 5px;
        }
    </style>
</head>

<body onload="threeStart();">
    <ul class="btn-list">
        <li>
            <button id="naiveSolverButton">Naive Solver</button>
        </li>
        <li>
            <button id="shuffleButton">Shuffle</button>
        </li>
        <li>
            <p class="error"></p>
        </li>
    </ul>
    <div id="canvas-frame"></div>
    <script>
        let renderer;
        let width;
        let height;
        let raycaster = new THREE.Raycaster(); // ray caster helps detect intersection.
        let mouse = new THREE.Vector2();
        let isRotating = false;
        let intersect;
        let normalize;
        let startPoint;
        let movePoint;
        let initStatus = [];
        let minCubeIndex;

        let startFaceNo = 0;
        let currentFaceNo = 0;
        let endFaceNo = 3;
        let isAutoSolver = false;

        // Six possible rotation directions.
        const XLine = new THREE.Vector3(1, 0, 0); // X
        const XLineR = new THREE.Vector3(-1, 0, 0); // Anti-X
        const YLine = new THREE.Vector3(0, 1, 0); // Y
        const YLineR = new THREE.Vector3(0, -1, 0); // Anti-Y
        const ZLine = new THREE.Vector3(0, 0, 1); // Z
        const ZLineR = new THREE.Vector3(0, 0, -1); // Anti-Z

        const cubeParams = { // cube arguments.
            x: 0,
            y: 0,
            z: 0,
            num: 3,
            len: 50,
            // [right, left, up, down, front, back]
            colors: ['rgba(255,193,37,1)', 'rgba(0,191,255,1)',
                'rgba(50,205,50,1)', 'rgba(178,34,34,1)',
                'rgba(255,255,0,1)', 'rgba(255,255,255,1)'
            ]
        };

        // Function to shuffle the cube.
        function shuffle() {
            if (!isRotating && !isAutoSolver) {
                const stepNum = parseInt(20 * Math.random()) + 1;
                console.log('random rotate ' + stepNum);

                let funcArr = [R, U, F, B, L, D, r, u, f, b, l, d];
                let stepArr = [];
                for (let i = 0; i < stepNum; i++) {
                    let num = parseInt(Math.random() * funcArr.length);
                    stepArr.push(funcArr[num]);
                }
                runMethodAtIndex(stepArr, 0, 0);
            }
        }

        // Naive Solver
        let currentStep = 1;
        let topColor;
        let buttomColor;
        let startTime = 0;
        let endTime = 0;
        let stepCount = 0;

        function naiveSolver() {
            if (!checkStep1() && !isRotating) {
                console.log('start naiveSolver');
                startTime = window.performance.now();
                console.log('start at:' + startTime);
                stepCount = 0;
                isAutoSolver = true;

                let topCenter = getCubeByIndex(10);
                topColor = getFaceColorByVector(topCenter, YLine);
                buttomColor = getOppositeColor(topColor);
                step1();
            } else {
                console.log('already reset');
            }
        }

        /**
         * Step 1 - First Layer Cross (White Cross)
        **/
        function checkStep1() {
            const indices = [1, 9, 11, 19];
            for (let i = 0; i < indices.length; i++) {
                const cube = getCubeByIndex(indices[i]);
                const color = getFaceColorByVector(cube, YLine); // get up face color
                if (color != buttomColor) {
                    return false;
                }
            }
            return true;
        }
        function step1() {
            if (checkStep1()) {
                console.log('start step2');
                currentStep = 2;
                step2();
                return;
            }

            step1Case1(0);
            step1Case1(1);
            step1Case1(2);
            step1Case1(3);

            step1Case2(0);
            step1Case2(1);
            step1Case2(2);
            step1Case2(3);

            step1Case3(0);
            step1Case3(1);
            step1Case3(2);
            step1Case3(3);

            step1Case4(0);
            step1Case4(1);
            step1Case4(2);
            step1Case4(3);

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step1');
            }
        }
        function step1Case1(rotateNum) {
            if (!isRotating) {
                const cube_3 = getCubeByIndex(3, rotateNum);
                const cube_9 = getCubeByIndex(9, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);

                if (getFaceColorByVector(cube_3, zLine) == buttomColor) {
                    if (getFaceColorByVector(cube_9, YLine) != buttomColor) {
                        l(rotateNum);
                    } else {
                        u(rotateNum);
                    }
                }
            }
        }
        function step1Case2(rotateNum) {
            if (!isRotating) {
                const cube_5 = getCubeByIndex(5, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);

                if (getFaceColorByVector(cube_5, zLine) == buttomColor) {
                    if (getFaceColorByVector(cube_11, YLine) != buttomColor) {
                        R(rotateNum);
                    } else {
                        u(rotateNum);
                    }
                }
            }
        }
        function step1Case3(rotateNum) {
            if (!isRotating) {
                const cube_15 = getCubeByIndex(15, rotateNum);
                const cube_9 = getCubeByIndex(9, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);

                if (getFaceColorByVector(cube_15, YLineR) == buttomColor) { //103、104
                    if (getFaceColorByVector(cube_9, YLine) != buttomColor) {
                        l(rotateNum);
                    } else {
                        u(rotateNum);
                    }
                }
            }
        }
        function step1Case4(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_7 = getCubeByIndex(7, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);

                if (getFaceColorByVector(cube_1, zLine) == buttomColor || getFaceColorByVector(cube_7, zLine) == buttomColor) { //105、106
                    if (getFaceColorByVector(cube_1, YLine) != buttomColor) {
                        F(rotateNum);
                    } else {
                        D(rotateNum)
                    }
                }
            }
        }

        /**
         * Step 2 - First Layer Corners (White Corners)
        **/
        function checkStep2() {
            const lines = [ZLine, XLine, ZLineR, XLineR];
            
            let indices = [4, 7, 14, 17, 22, 25, 12, 15];
            let arr = getCubesByIndices(indices);
            for (let i = 0; i < arr.length; i++) {
                let index = parseInt(i / 2);
                let color1 = getFaceColorByVector(arr[i], lines[index]);
                if (color1 == topColor || color1 == buttomColor) {
                    return false;
                }
                if (i % 2 == 0) {
                    let color2 = getFaceColorByVector(arr[i + 1], lines[index]);
                    if (color1 != color2) {
                        return false;
                    }
                }
            }
            // Check buttom cross.
            for (let i = 1; i < arr.length; i = i + 2) {
                let color = getFaceColorByVector(arr[i], YLineR);
                if (color != buttomColor) {
                    return false;
                }
            }
            indices = [6, 8, 26, 24];
            arr = getCubesByIndices(indices);
            for (let i = 0; i < arr.length; i++) {
                let color = getFaceColorByVector(arr[i], YLineR);
                if (color == buttomColor) {
                    return false;
                }
            }

            return true;
        }
        function step2() {
            if (checkStep2()) {
                console.log('start step3');
                currentStep = 3;
                step3();
                return;
            }

            step2Case1(0);
            step2Case1(1);
            step2Case1(2);
            step2Case1(3);

            step2Case2(0);
            step2Case2(1);
            step2Case2(2);
            step2Case2(3);

            step2Case3(0);
            step2Case3(1);
            step2Case3(2);
            step2Case3(3);

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step2');
            }
        }
        function step2Case1(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);

                if (getFaceColorByVector(cube_1, YLine) == buttomColor) {
                    if (getFaceColorByVector(cube_1, zLine) == getFaceColorByVector(cube_4, zLine)) {
                        F(rotateNum, function() {
                            F(rotateNum);
                        });
                    } else {
                        u(rotateNum, function() {
                            rotateNum = (rotateNum + 1) % 4;
                            step2Case1(rotateNum);
                        });
                    }
                }
            }
        }
        function step2Case2(rotateNum) {
            if (!isRotating) {
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_8 = getCubeByIndex(8, rotateNum);
                const cube_2 = getCubeByIndex(2, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                if (getFaceColorByVector(cube_7, YLineR) == buttomColor &&
                    getFaceColorByVector(cube_8, YLineR) == buttomColor) {
                    if (getFaceColorByVector(cube_2, xLine) != buttomColor) {
                        R(rotateNum, function() {
                            u(rotateNum, function() {
                                r(rotateNum);
                            });
                        })
                    } else {
                        f(rotateNum, function() {
                            u(rotateNum, function() {
                                F(rotateNum);
                            });
                        })
                    }
                }
            }
        }
        function step2Case3(rotateNum) {
            if (!isRotating) {
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_6 = getCubeByIndex(6, rotateNum);
                const cube_0 = getCubeByIndex(0, rotateNum);
                const xLineR = rotateAxisByYLine(XLineR, rotateNum);
                if (getFaceColorByVector(cube_7, YLineR) == buttomColor &&
                    getFaceColorByVector(cube_6, YLineR) == buttomColor) {
                    if (getFaceColorByVector(cube_0, xLineR) != buttomColor) {
                        l(rotateNum, function() {
                            u(rotateNum, function() {
                                L(rotateNum)
                            });
                        })
                    } else {
                        f(rotateNum, function() {
                            u(rotateNum, function() {
                                F(rotateNum);
                            });
                        })
                    }
                }
            }
        }

        /**
         * Step 3 - Buttom Corner
        **/
        function checkStep3() {
            const indices1 = [4, 6, 7, 8];
            const indices2 = [14, 8, 17, 26];
            const indices3 = [22, 24, 25, 26];
            const indices4 = [12, 6, 15, 24];
            if(!checkStep3Item(indices1, ZLine)) return false;
            if(!checkStep3Item(indices2, XLine)) return false;
            if(!checkStep3Item(indices3, ZLineR)) return false;
            if(!checkStep3Item(indices4, XLineR)) return false;
            return true;
        }

        function step3() {
            if (checkStep3()) {
                console.log('start step4');
                currentStep = 4;
                startFaceNo = 0;
                endFaceNo = 3;
                step4();
                return;
            }
            step3Case1(0);
            step3Case1(1);
            step3Case1(2);
            step3Case1(3);

            step3Case2(0);
            step3Case2(1);
            step3Case2(2);
            step3Case2(3);

            step3Case3(0);
            step3Case3(1);
            step3Case3(2);
            step3Case3(3);

            step3Case4(0);
            step3Case4(1);
            step3Case4(2);
            step3Case4(3);

            step3Case5(0);
            step3Case5(1);
            step3Case5(2);
            step3Case5(3);

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step3');
            }
        }
        function step3Case1(rotateNum, startNum) {
            if (!isRotating) {
                const cube_2 = getCubeByIndex(2, rotateNum);
                const cube_8 = getCubeByIndex(8, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const cube_17 = getCubeByIndex(17, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const zLineR = rotateAxisByYLine(ZLineR, rotateNum);
                const xLineR = rotateAxisByYLine(XLineR, rotateNum);
                const cube_2_Z_color = getFaceColorByVector(cube_2, zLine);
                const cube_2_Y_color = getFaceColorByVector(cube_2, YLine);

                if (getFaceColorByVector(cube_2, xLine) == buttomColor && !cube_2.skipNext) {
                    if (getFaceColorByVector(cube_8, YLineR) != buttomColor &&
                        getFaceColorByVector(cube_4, zLine) == cube_2_Z_color &&
                        getFaceColorByVector(cube_7, zLine) == cube_2_Z_color &&
                        getFaceColorByVector(cube_14, xLine) == cube_2_Y_color &&
                        getFaceColorByVector(cube_17, xLine) == cube_2_Y_color) {
                        R(rotateNum, function() {
                            U(rotateNum, function() {
                                r(rotateNum)
                            })
                        })
                    } else {
                        u(rotateNum, function() {
                            rotateNum++;
                            if (rotateNum >= 4) rotateNum = 0;
                            if (startNum != rotateNum) { // Avoid loop by repeated check.
                                if (startNum == null || startNum == undefined) {
                                    startNum = rotateNum - 1;
                                    step3Case1(rotateNum, startNum);
                                } else {
                                    step3Case1(rotateNum, startNum);
                                }
                            } else {
                                let cube_2 = getCubeByIndex(2, rotateNum);
                                cube_2.skipNext = true;
                                step3();
                            }
                        })
                    }
                }
            }
        }
        function step3Case2(rotateNum, startNum) {
            if (!isRotating) {
                const cube_2 = getCubeByIndex(2, rotateNum);
                const cube_8 = getCubeByIndex(8, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const cube_17 = getCubeByIndex(17, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const zLineR = rotateAxisByYLine(ZLineR, rotateNum);
                const xLineR = rotateAxisByYLine(XLineR, rotateNum);
                const cube_2_Y_color = getFaceColorByVector(cube_2, YLine);
                const cube_2_X_color = getFaceColorByVector(cube_2, xLine);

                if (getFaceColorByVector(cube_2, zLine) == buttomColor && !cube_2.skipNext) {
                    if (getFaceColorByVector(cube_8, YLineR) != buttomColor &&
                        getFaceColorByVector(cube_4, zLine) == cube_2_Y_color &&
                        getFaceColorByVector(cube_7, zLine) == cube_2_Y_color &&
                        getFaceColorByVector(cube_14, xLine) == cube_2_X_color &&
                        getFaceColorByVector(cube_17, xLine) == cube_2_X_color) {
                        f(rotateNum, function() {
                            u(rotateNum, function() {
                                F(rotateNum)
                            })
                        })
                    } else {
                        u(rotateNum, function() {
                            rotateNum++;
                            if (rotateNum >= 4) {
                                rotateNum = 0;
                            }
                            if (startNum != rotateNum) {
                                if (startNum == null || startNum == undefined) {
                                    startNum = rotateNum - 1;
                                    step3Case2(rotateNum, startNum);
                                } else {
                                    step3Case2(rotateNum, startNum);
                                }
                            } else {
                                let cube_2 = getCubeByIndex(2, rotateNum);
                                cube_2.skipNext = true;
                                step3();
                            }
                        })
                    }
                }
            }
        }
        function step3Case3(rotateNum, startNum) {
            if (!isRotating) {
                const cube_2 = getCubeByIndex(2, rotateNum);
                const cube_8 = getCubeByIndex(8, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const cube_17 = getCubeByIndex(17, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const zLineR = rotateAxisByYLine(ZLineR, rotateNum);
                const xLineR = rotateAxisByYLine(XLineR, rotateNum);
                const cube_2_Z_color = getFaceColorByVector(cube_2, zLine);
                const cube_2_X_color = getFaceColorByVector(cube_2, xLine);

                if (getFaceColorByVector(cube_2, YLine) == buttomColor && !cube_2.skipNext) {
                    if (getFaceColorByVector(cube_8, YLineR) != buttomColor &&
                        getFaceColorByVector(cube_14, xLine) == cube_2_Z_color &&
                        getFaceColorByVector(cube_17, xLine) == cube_2_Z_color &&
                        getFaceColorByVector(cube_4, zLine) == cube_2_X_color &&
                        getFaceColorByVector(cube_7, zLine) == cube_2_X_color) {
                        // To step3Case2
                        f(rotateNum, function() {
                            u(rotateNum, function() {
                                u(rotateNum, function() {
                                    F(rotateNum, function() {
                                        U(rotateNum)
                                    })
                                })
                            })
                        })
                    } else {
                        u(rotateNum, function() {
                            rotateNum++;
                            if (rotateNum >= 4) {
                                rotateNum = 0;
                            }
                            if (startNum != rotateNum) {
                                if (startNum == null || startNum == undefined) {
                                    startNum = rotateNum - 1;
                                    step3Case3(rotateNum, startNum);
                                } else {
                                    step3Case3(rotateNum, startNum);
                                }
                            } else {
                                let cube_2 = getCubeByIndex(2, rotateNum);
                                cube_2.skipNext = true;
                                step3();
                            }
                        })
                    }
                }
            }
        }
        function step3Case4(rotateNum) {
            if (!isRotating) {
                const cube_8 = getCubeByIndex(8, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const cube_17 = getCubeByIndex(17, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const cube_8_Z_color = getFaceColorByVector(cube_8, zLine);
                const cube_8_YR_color = getFaceColorByVector(cube_8, YLineR);

                if (getFaceColorByVector(cube_8, xLine) == buttomColor) {
                    if (getFaceColorByVector(cube_17, xLine) == cube_8_Z_color &&
                        getFaceColorByVector(cube_14, xLine) == cube_8_Z_color &&
                        getFaceColorByVector(cube_4, zLine) == cube_8_YR_color &&
                        getFaceColorByVector(cube_7, zLine) == cube_8_YR_color) {
                        // To step3Case1
                        f(rotateNum, function() {
                            U(rotateNum, function() {
                                F(rotateNum)
                            })
                        })
                    } else {
                        // To step3Case3
                        f(rotateNum, function() {
                            u(rotateNum, function() {
                                F(rotateNum)
                            })
                        })
                    }
                }
            }
        }
        function step3Case5(rotateNum) {
            if (!isRotating) {
                const cube_8 = getCubeByIndex(8, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_7 = getCubeByIndex(7, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const cube_17 = getCubeByIndex(17, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const cube_8_X_color = getFaceColorByVector(cube_8, xLine);
                const cube_8_YR_color = getFaceColorByVector(cube_8, YLineR);

                if (getFaceColorByVector(cube_8, zLine) == buttomColor) {
                    if (getFaceColorByVector(cube_7, zLine) == cube_8_X_color &&
                        getFaceColorByVector(cube_4, zLine) == cube_8_X_color &&
                        getFaceColorByVector(cube_14, xLine) == cube_8_YR_color &&
                        getFaceColorByVector(cube_17, xLine) == cube_8_YR_color) {
                        // To step3Case2
                        f(rotateNum, function() {
                            u(rotateNum, function() {
                                F(rotateNum, function() {
                                    U(rotateNum)
                                })
                            })
                        })
                    } else {
                        // To step3Case3
                        R(rotateNum, function() {
                            u(rotateNum, function() {
                                r(rotateNum)
                            })
                        })
                    }
                }
            }
        }
        function checkStep3Item(indices, line) {
            if (indices.length > 0) {
                let arr = getCubesByIndices(indices);
                for (let i = 1; i < arr.length; i++) {
                    if (getFaceColorByVector(arr[i], line) != getFaceColorByVector(arr[0], line)) {
                        return false;
                    }
                    if (getFaceColorByVector(arr[i], YLineR) != buttomColor) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * Step 4 - 
        **/
        function step4() {
            if (checkStep4()) {
                console.log('start step5');
                currentStep = 5;
                step5();
                return;
            }
            step4Face(currentFaceNo);
            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step4');
            }
        }
        function checkStep4() {
            if (!checkStep3()) return false;

            const cube_3 = getCubeByIndex(3);
            const cube_4 = getCubeByIndex(4);
            const cube_5 = getCubeByIndex(5);
            const cube_3_Z_color = getFaceColorByVector(cube_3, ZLine);
            if (getFaceColorByVector(cube_4, ZLine) != cube_3_Z_color ||
                getFaceColorByVector(cube_5, ZLine) != cube_3_Z_color) {
                return false;
            }

            const cube_14 = getCubeByIndex(14);
            const cube_23 = getCubeByIndex(23);
            const cube_5_X_color = getFaceColorByVector(cube_5, XLine);
            if (getFaceColorByVector(cube_14, XLine) != cube_5_X_color ||
                getFaceColorByVector(cube_23, XLine) != cube_5_X_color) {
                return false;
            }

            const cube_21 = getCubeByIndex(21);
            const cube_22 = getCubeByIndex(22);
            const cube_23_ZR_color = getFaceColorByVector(cube_23, ZLineR);
            if (getFaceColorByVector(cube_21, ZLineR) != cube_23_ZR_color ||
                getFaceColorByVector(cube_22, ZLineR) != cube_23_ZR_color) {
                return false;
            }

            const cube_12 = getCubeByIndex(12);
            const cube_3_XR_color = getFaceColorByVector(cube_3, XLineR);
            if (getFaceColorByVector(cube_12, XLineR) != cube_3_XR_color ||
                getFaceColorByVector(cube_21, XLineR) != cube_3_XR_color) {
                return false;
            }

            return true;
        }

        function rotate401(rotateNum, callback) {
            rotateNum = (rotateNum + 4) % 4;
            const arr = [r, u, r, u, r, U, R, U, R];
            runMethodAtIndex(arr, 0, rotateNum, callback);
        }

        function rotate401_Opposite(rotateNum, callback) {
            rotateNum = (rotateNum + 4) % 4;
            const arr = [r, u, r, u, R, U, R, U, R];
            runMethodAtIndex(arr, 0, rotateNum, callback);
        }

        function rotate402(rotateNum, callback) {
            rotateNum = (rotateNum + 4) % 4;
            const arr = [F, U, F, U, F, u, f, u, f];
            runMethodAtIndex(arr, 0, rotateNum, callback);
        }

        function rotate402_Opposite(rotateNum, callback) {
            rotateNum = (rotateNum + 4) % 4;
            const arr = [F, U, F, U, f, u, f, u, f];
            runMethodAtIndex(arr, 0, rotateNum, callback);
        }
        function step4Face(rotateNum) {
            if (!isRotating) {
                rotateNum = (rotateNum + 4) % 4;
                currentFaceNo = rotateNum;
                const cube_3 = getCubeByIndex(3, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_5 = getCubeByIndex(5, rotateNum);
                const cube_6 = getCubeByIndex(6, rotateNum);
                const cube_9 = getCubeByIndex(9, rotateNum);
                const cube_19 = getCubeByIndex(19, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_21 = getCubeByIndex(21, rotateNum);
                const cube_23 = getCubeByIndex(23, rotateNum);

                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const xLineR = rotateAxisByYLine(XLineR, rotateNum);
                const zLineR = rotateAxisByYLine(ZLineR, rotateNum);

                const cube_4_Z_color = getFaceColorByVector(cube_4, zLine);
                const cube_6_XR_color = getFaceColorByVector(cube_6, xLineR);
                const cube_14_X_color = getFaceColorByVector(cube_14, xLine);

                if (getFaceColorByVector(cube_3, zLine) != cube_4_Z_color) {
                    if (getFaceColorByVector(cube_9, YLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_9, xLineR) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        rotate402(rotateNum - 1);
                        return;
                    } else if (getFaceColorByVector(cube_9, xLineR) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_9, YLine) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        u(0, function() {
                            rotate401(rotateNum - 1);
                        });
                        return;
                    } else if ((getFaceColorByVector(cube_19, YLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_19, zLineR) == cube_6_XR_color || rotateNum == startFaceNo)) ||
                        (getFaceColorByVector(cube_19, zLineR) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_19, YLine) == cube_6_XR_color || rotateNum == startFaceNo)) ||
                        (getFaceColorByVector(cube_11, YLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_11, xLine) == cube_6_XR_color || rotateNum == startFaceNo)) ||
                        (getFaceColorByVector(cube_11, xLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_11, YLine) == cube_6_XR_color || rotateNum == startFaceNo)) ||
                        (getFaceColorByVector(cube_1, YLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_1, zLine) == cube_6_XR_color || rotateNum == startFaceNo)) ||
                        (getFaceColorByVector(cube_1, zLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_1, YLine) == cube_6_XR_color || rotateNum == startFaceNo))) {
                        U(0);
                        return;
                    } else if (getFaceColorByVector(cube_5, zLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_5, xLine) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        rotate401_Opposite(rotateNum);
                        return;
                    } else if (getFaceColorByVector(cube_3, xLineR) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_3, zLine) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        let tempNum = rotateNum - 1;
                        rotate402(tempNum, function() {
                            U(tempNum, function() {
                                rotate401(tempNum);
                            });
                        });
                        return;
                    } else if (getFaceColorByVector(cube_23, xLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_23, zLineR) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        rotate402_Opposite(rotateNum - 3);
                        return;
                    } else if (getFaceColorByVector(cube_23, zLineR) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_23, xLine) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        rotate402_Opposite(rotateNum - 3);
                        return;
                    } else if (getFaceColorByVector(cube_5, xLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_5, zLine) == cube_6_XR_color || rotateNum == startFaceNo)) {
                        rotate402_Opposite(rotateNum);
                        return;
                    } else if ((getFaceColorByVector(cube_21, xLineR) == cube_4_Z_color || getFaceColorByVector(cube_21, zLineR) == cube_4_Z_color) && rotateNum <= 0) {
                        rotate402_Opposite(rotateNum - 2);
                        return;
                    }
                }
                if (getFaceColorByVector(cube_5, zLine) != cube_4_Z_color) {
                    if (getFaceColorByVector(cube_11, YLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_11, xLine) == cube_14_X_color || rotateNum != endFaceNo)) {
                        rotate401(rotateNum);
                        return;
                    } else if (getFaceColorByVector(cube_11, xLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_11, YLine) == cube_14_X_color || rotateNum != endFaceNo)) {
                        U(0, function() {
                            rotate402(rotateNum);
                        });
                        return;
                    } else if ((getFaceColorByVector(cube_1, YLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_1, zLine) == cube_14_X_color || rotateNum != endFaceNo)) ||
                        (getFaceColorByVector(cube_1, zLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_1, YLine) == cube_14_X_color || rotateNum != endFaceNo)) ||
                        (getFaceColorByVector(cube_9, YLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_9, xLineR) == cube_14_X_color || rotateNum != endFaceNo)) ||
                        (getFaceColorByVector(cube_9, xLineR) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_9, YLine) == cube_14_X_color || rotateNum != endFaceNo)) ||
                        (getFaceColorByVector(cube_19, YLine) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_19, zLineR) == cube_14_X_color || rotateNum != endFaceNo)) ||
                        (getFaceColorByVector(cube_19, zLineR) == cube_4_Z_color &&
                            (getFaceColorByVector(cube_19, YLine) == cube_14_X_color || rotateNum != endFaceNo))) {
                        u(0);
                        return;
                    } else if (getFaceColorByVector(cube_5, xLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_5, zLine) == cube_14_X_color || rotateNum != endFaceNo)) {
                        rotate402_Opposite(rotateNum);
                        return;
                    } else if ((getFaceColorByVector(cube_21, xLineR) == cube_4_Z_color || getFaceColorByVector(cube_21, zLineR) == cube_4_Z_color) && rotateNum <= 0) {
                        rotate402_Opposite(rotateNum - 2);
                        return;
                    } else if (getFaceColorByVector(cube_23, zLineR) == cube_4_Z_color && rotateNum == startFaceNo) {
                        rotate402_Opposite(rotateNum - 3);
                        return;
                    } else if (getFaceColorByVector(cube_23, xLine) == cube_4_Z_color &&
                        (getFaceColorByVector(cube_23, zLineR) == cube_14_X_color || rotateNum != endFaceNo)) {
                        rotate402_Opposite(rotateNum - 3);
                        return;
                    }
                }

                if (getFaceColorByVector(cube_3, zLine) != cube_4_Z_color || getFaceColorByVector(cube_5, zLine) != cube_4_Z_color) {
                    // Extreme case for one face. Restart with this face.
                    startFaceNo = currentFaceNo;
                    if (startFaceNo > 0) {
                        endFaceNo = startFaceNo - 1;
                    } else {
                        endFaceNo = 3;
                    }
                } else {
                    currentFaceNo++;
                    if (currentFaceNo > 3) {
                        currentFaceNo = 0;
                    }
                }
                step4();
            }
        }

        /**
         * Step 5 - Up Cross
        **/
        function checkStep5() {
            if (!checkStep4()) return false;
            const cube_10 = getCubeByIndex(10);
            const cube_1 = getCubeByIndex(1);
            const cube_11 = getCubeByIndex(11);
            const cube_9 = getCubeByIndex(9);
            const cube_19 = getCubeByIndex(19);
            if (getFaceColorByVector(cube_10, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_1, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_11, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_9, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_19, YLine) != topColor) return false;
            return true;
        }
        function step5() {
            if (checkStep5()) {
                console.log('start step6');
                currentStep = 6;
                step6();
                return;
            }

            step5Case1(0);
            step5Case1(1);
            step5Case1(2);
            step5Case1(3);

            step5Case2(0);
            step5Case2(1);
            step5Case2(2);
            step5Case2(3);

            step5Case3(0);
            step5Case3(1);
            step5Case3(2);
            step5Case3(3);

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step5');
            }
        }
        function rotate501(rotateNum, callback) {
            const arr = [r, u, f, U, F, R];
            runMethodAtIndex(arr, 0, rotateNum, callback);
        }
        function rotate502(rotateNum, callback) {
            const arr = [r, f, u, F, U, R];
            runMethodAtIndex(arr, 0, rotateNum, callback);
        }
        function step5Case1(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_9 = getCubeByIndex(9, rotateNum);
                const cube_19 = getCubeByIndex(19, rotateNum);
                const cube_10 = getCubeByIndex(10, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                if (getFaceColorByVector(cube_10, YLine) == topColor &&
                    getFaceColorByVector(cube_9, YLine) == topColor &&
                    getFaceColorByVector(cube_19, YLine) == topColor &&
                    getFaceColorByVector(cube_1, zLine) == topColor &&
                    getFaceColorByVector(cube_11, xLine) == topColor) {
                    rotate501(rotateNum);
                }
            }
        }
        function step5Case2(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_19 = getCubeByIndex(19, rotateNum);
                const cube_10 = getCubeByIndex(10, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                if (getFaceColorByVector(cube_10, YLine) == topColor &&
                    getFaceColorByVector(cube_1, YLine) == topColor &&
                    getFaceColorByVector(cube_19, YLine) == topColor &&
                    getFaceColorByVector(cube_11, xLine) == topColor) {
                    rotate501(rotateNum);
                }
            }
        }
        function step5Case3(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_10 = getCubeByIndex(10, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                if (getFaceColorByVector(cube_10, YLine) == topColor &&
                    getFaceColorByVector(cube_1, zLine) == topColor &&
                    getFaceColorByVector(cube_11, xLine) == topColor) {
                    rotate501(rotateNum, function() {
                        U(rotateNum, function() {
                            rotate502(rotateNum);
                        })
                    });
                }
            }
        }
        /**
         * Step 6 - Up Face
        **/
        function checkStep6() {
            if (!checkStep5()) return false;

            const cube_0 = getCubeByIndex(0);
            const cube_2 = getCubeByIndex(2);
            const cube_18 = getCubeByIndex(18);
            const cube_20 = getCubeByIndex(20);
            if (getFaceColorByVector(cube_0, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_2, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_18, YLine) != topColor) return false;
            if (getFaceColorByVector(cube_20, YLine) != topColor) return false;
            return true;
        }
        function step6() {
            if (checkStep6()) {
                console.log('start step7');
                currentStep = 7;
                step7();
                return;
            }

            step6Case1(0);
            step6Case1(1);
            step6Case1(2);
            step6Case1(3);

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step6');
            }
        }

        function rotate601(rotateNum) {
            const arr = [r, U, L, u, R, U, l, u];
            runMethodAtIndex(arr, 0, rotateNum);
        }

        function rotate602(rotateNum) {
            const arr = [U, L, u, r, U, l, u, R];
            runMethodAtIndex(arr, 0, rotateNum);
        }

        function rotate603(rotateNum) {
            const arr = [R, U, r, U, R, U, U, r];
            runMethodAtIndex(arr, 0, rotateNum);
        }
        function step6Case1(rotateNum) {
            if (!isRotating) {
                const cube_0 = getCubeByIndex(0, rotateNum);
                const cube_2 = getCubeByIndex(2, rotateNum);
                const cube_20 = getCubeByIndex(20, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                if (getFaceColorByVector(cube_0, zLine) == topColor &&
                    getFaceColorByVector(cube_2, xLine) == topColor) {
                    rotate601(rotateNum);
                } else if (getFaceColorByVector(cube_2, zLine) == topColor &&
                    getFaceColorByVector(cube_20, xLine) == topColor) {
                    rotate602(rotateNum);
                } else if (getFaceColorByVector(cube_0, zLine) == topColor) {
                    rotate603(rotateNum);
                }
            }
        }

        /**
         * Step 7 - Up Face
        **/
        function checkStep7() {
            if (!checkStep6()) return false;

            const cube_1 = getCubeByIndex(1);
            const cube_4 = getCubeByIndex(4);
            const cube_11 = getCubeByIndex(11);
            const cube_14 = getCubeByIndex(14);
            const cube_19 = getCubeByIndex(19);
            const cube_22 = getCubeByIndex(22);
            const cube_9 = getCubeByIndex(9);
            const cube_12 = getCubeByIndex(12);

            if (getFaceColorByVector(cube_1, ZLine) != getFaceColorByVector(cube_4, ZLine)) return false;
            if (getFaceColorByVector(cube_11, XLine) != getFaceColorByVector(cube_14, XLine)) return false;
            if (getFaceColorByVector(cube_19, ZLineR) != getFaceColorByVector(cube_22, ZLineR)) return false;
            if (getFaceColorByVector(cube_9, XLineR) != getFaceColorByVector(cube_12, XLineR)) return false;

            return true;
        }

        function step7() {
            if (checkStep7()) {
                console.log('start step8');
                currentStep = 8;
                step8();
                return;
            }

            step7Case1(0);
            step7Case1(1);
            step7Case1(2);
            step7Case1(3);

            step7Case2(0);
            step7Case2(1);
            step7Case2(2);
            step7Case2(3);

            step7Case3();

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step7');
            }
        }
        function step7Case1(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const cube_4_Z_color = getFaceColorByVector(cube_4, zLine);
                if (getFaceColorByVector(cube_1, zLine) != cube_4_Z_color &&
                    cube_4_Z_color == getFaceColorByVector(cube_11, xLine) &&
                    cube_4_Z_color != getFaceColorByVector(cube_14, xLine)) {
                    F(rotateNum, function() {
                        F(rotateNum, function() {
                            U(rotateNum, function() {
                                r(rotateNum, function() {
                                    L(rotateNum, function() {
                                        F(rotateNum, function() {
                                            F(rotateNum, function() {
                                                R(rotateNum, function() {
                                                    l(rotateNum, function() {
                                                        U(rotateNum, function() {
                                                            F(rotateNum, function() {
                                                                F(rotateNum)
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                }
            }
        }
        function step7Case2(rotateNum) {
            if (!isRotating) {
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_4 = getCubeByIndex(4, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_14 = getCubeByIndex(14, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const cube_1_Z_color = getFaceColorByVector(cube_1, zLine);
                if (cube_1_Z_color != getFaceColorByVector(cube_4, zLine) &&
                    cube_1_Z_color == getFaceColorByVector(cube_14, xLine) &&
                    cube_1_Z_color != getFaceColorByVector(cube_11, xLine)) {
                    F(rotateNum, function() {
                        F(rotateNum, function() {
                            u(rotateNum, function() {
                                r(rotateNum, function() {
                                    L(rotateNum, function() {
                                        F(rotateNum, function() {
                                            F(rotateNum, function() {
                                                R(rotateNum, function() {
                                                    l(rotateNum, function() {
                                                        u(rotateNum, function() {
                                                            F(rotateNum, function() {
                                                                F(rotateNum)
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                }
            }
        }
        // 顶棱归位 第三种情况（有两个对应的面顶棱完成，另外两个对应的面顶棱没有）
        function step7Case3() {
            if (!isRotating && !checkStep7()) {
                u(0);
            }
        }
        
        /**
         * Step 8 - 
        **/
        function checkStep8Item(indices, line) {
            if (indices.length > 0) {
                let arr = getCubesByIndices(indices);
                let color = getFaceColorByVector(arr[0], line)
                for (let i = 1; i < arr.length; i++) {
                    if (getFaceColorByVector(arr[i], line) != color) {
                        return false;
                    }
                }
            }
            return true;
        }
        function checkStep8() {
            const indices1 = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            const indices2 = [2, 5, 8, 11, 14, 17, 20, 23, 26];
            const indices3 = [18, 19, 20, 21, 22, 23, 24, 25, 26];
            const indices4 = [0, 3, 6, 9, 12, 15, 18, 21, 24];
            if(!checkStep8Item(indices1, ZLine)) return false;
            if(!checkStep8Item(indices2, ZLine)) return false;
            if(!checkStep8Item(indices3, ZLine)) return false;
            if(!checkStep8Item(indices4, ZLine)) return false;
            return true;
        }
        function step8() {
            if (checkStep8()) {
                isAutoSolver = false;
                endTime = window.performance.now();
                console.log('end at:' + endTime);
                console.log('total times:' + (endTime - startTime));
                console.log('total steps:' + stepCount);
                console.log('end naiveSolver');
                return;
            }

            step8Case1(0);
            step8Case1(1);
            step8Case1(2);
            step8Case1(3);

            step8Case2(0);
            step8Case2(1);
            step8Case2(2);
            step8Case2(3);

            step8Case3();

            if (!isRotating) {
                isAutoSolver = false;
                console.log('something wrong in step8');
            }
        }

        function rotate8_1(rotateNum) {
            const arr = [R, R, B, B, R, F, r, B, B, R, f, R];
            runMethodAtIndex(arr, 0, rotateNum);
        }

        function rotate8_2(rotateNum) {
            const arr = [L, L, B, B, l, f, L, B, B, l, F, l];
            runMethodAtIndex(arr, 0, rotateNum);
        }
        function step8Case1(rotateNum) {
            if (!isRotating) {
                const cube_2 = getCubeByIndex(2, rotateNum);
                const cube_20 = getCubeByIndex(20, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                if (getFaceColorByVector(cube_2, xLine) == getFaceColorByVector(cube_20, xLine) &&
                    getFaceColorByVector(cube_2, xLine) != getFaceColorByVector(cube_11, xLine)) {
                    rotate8_1(rotateNum);
                }
            }
        }
        function step8Case2(rotateNum) {
            if (!isRotating) {
                const cube_0 = getCubeByIndex(0, rotateNum);
                const cube_1 = getCubeByIndex(1, rotateNum);
                const cube_2 = getCubeByIndex(2, rotateNum);
                const cube_11 = getCubeByIndex(11, rotateNum);
                const cube_20 = getCubeByIndex(20, rotateNum);
                const xLine = rotateAxisByYLine(XLine, rotateNum);
                const zLine = rotateAxisByYLine(ZLine, rotateNum);
                if (getFaceColorByVector(cube_0, zLine) == getFaceColorByVector(cube_20, xLine) &&
                    getFaceColorByVector(cube_1, zLine) == getFaceColorByVector(cube_2, zLine) &&
                    getFaceColorByVector(cube_11, xLine) == getFaceColorByVector(cube_20, xLine) &&
                    getFaceColorByVector(cube_0, zLine) != getFaceColorByVector(cube_1, zLine) &&
                    getFaceColorByVector(cube_20, xLine) != getFaceColorByVector(cube_20, xLine)) {
                    rotate8_2(rotateNum);
                }
            }
        }
        function step8Case3() {
            if (!isRotating) {
                const cube_0 = getCubeByIndex(0);
                const cube_2 = getCubeByIndex(2);
                const cube_20 = getCubeByIndex(20);
                const cube_18 = getCubeByIndex(18);
                if (getFaceColorByVector(cube_0, ZLine) != getFaceColorByVector(cube_2, ZLine) &&
                    getFaceColorByVector(cube_2, XLine) != getFaceColorByVector(cube_20, XLine) &&
                    getFaceColorByVector(cube_20, ZLineR) != getFaceColorByVector(cube_18, ZLineR) &&
                    getFaceColorByVector(cube_18, XLineR) != getFaceColorByVector(cube_0, XLineR)) {
                    rotate8_1(0);
                }
            }
        }

        /**
            * run methods in order by index.
            * @param  {[type]}   arr       [method array]
            * @param  {[type]}   index     [current method index]
            * @param  {[type]}   rotateNum [number of rotations]
            * @param  {Function} callback  [callback function after all methods done]
            */
        function runMethodAtIndex(arr, index, rotateNum, callback) {
            if (index >= arr.length - 1) {
                if (callback) {
                    arr[index](rotateNum, callback);
                } else {
                    arr[index](rotateNum);
                }
            } else {
                arr[index](rotateNum, function() {
                    if (index < arr.length - 1) {
                        index++;
                        runMethodAtIndex(arr, index, rotateNum, callback);
                    }
                })
            }
        }

        /*
         * Basic methods: U、F、L、D、R、u、f、l、d
         */
        function U(rotateNum, callback) {
            stepCount++;
            let cube_2 = getCubeByIndex(2, rotateNum);
            let zLine = rotateAxisByYLine(ZLine, rotateNum);
            let xLineR = rotateAxisByYLine(XLineR, rotateNum);
            normalize = zLine;
            rotateMove(cube_2, xLineR, callback);
        }

        function u(rotateNum, callback) {
            stepCount++;
            let cube_2 = getCubeByIndex(2, rotateNum);
            let xLine = rotateAxisByYLine(XLine, rotateNum);
            let zLineR = rotateAxisByYLine(ZLineR, rotateNum);
            normalize = xLine;
            rotateMove(cube_2, zLineR, callback);
        }

        function F(rotateNum, callback) {
            stepCount++;
            let cube_2 = getCubeByIndex(2, rotateNum);
            let xLine = rotateAxisByYLine(XLine, rotateNum);
            normalize = xLine;
            rotateMove(cube_2, YLineR, callback);
        }

        function f(rotateNum, callback) {
            stepCount++;
            let cube_2 = getCubeByIndex(2, rotateNum);
            let xLineR = rotateAxisByYLine(XLineR, rotateNum);
            normalize = YLine;
            rotateMove(cube_2, xLineR, callback)
        }

        function L(rotateNum, callback) {
            stepCount++;
            let cube_0 = getCubeByIndex(0, rotateNum);
            let zLine = rotateAxisByYLine(ZLine, rotateNum);
            normalize = zLine;
            rotateMove(cube_0, YLineR, callback);
        }

        function l(rotateNum, callback) {
            stepCount++;
            let cube_0 = getCubeByIndex(0, rotateNum);
            let zLineR = rotateAxisByYLine(ZLineR, rotateNum);
            normalize = YLine;
            rotateMove(cube_0, zLineR, callback);
        }

        function D(rotateNum, callback) {
            stepCount++;
            let cube_8 = getCubeByIndex(8, rotateNum);
            let xLine = rotateAxisByYLine(XLine, rotateNum);
            let zLineR = rotateAxisByYLine(ZLineR, rotateNum);
            normalize = xLine;
            rotateMove(cube_8, zLineR, callback);
        }

        function d(rotateNum, callback) {
            stepCount++;
            let cube_8 = getCubeByIndex(8, rotateNum);
            let zLine = rotateAxisByYLine(ZLine, rotateNum);
            let xLineR = rotateAxisByYLine(XLineR, rotateNum);
            normalize = zLine;
            rotateMove(cube_8, xLineR, callback);
        }

        function R(rotateNum, callback) {
            stepCount++;
            let cube_2 = getCubeByIndex(2, rotateNum);
            let zLineR = rotateAxisByYLine(ZLineR, rotateNum);
            normalize = YLine;
            rotateMove(cube_2, zLineR, callback);
        }

        function r(rotateNum, callback) {
            stepCount++;
            let cube_2 = getCubeByIndex(2, rotateNum);
            let zLine = rotateAxisByYLine(ZLine, rotateNum);
            normalize = zLine;
            rotateMove(cube_2, YLineR, callback);
        }

        function B(rotateNum, callback) {
            stepCount++;
            let cube_20 = getCubeByIndex(20, rotateNum);
            let xLine = rotateAxisByYLine(XLine, rotateNum);
            normalize = xLine;
            rotateMove(cube_20, YLine, callback);
        }

        function b(rotateNum, callback) {
            stepCount++;
            let cube_20 = getCubeByIndex(20, rotateNum);
            let xLine = rotateAxisByYLine(XLine, rotateNum);
            normalize = xLine;
            rotateMove(cube_20, YLineR, callback);
        }


        /***********************************************  HELPER functions ***********************************************/
        /*
         * Function to get the cube by index after clockwise rotation around Y
         */
        function getCubeByIndex(index, rotateNum) {
            let tempIndex = index;
            let tempRotateNum = rotateNum;
            while (rotateNum > 0) {
                if (parseInt(index / 9) == 0) {
                    if (index % 3 == 0) {
                        index += 2;
                    } else if (index % 3 == 1) {
                        index += 10;
                    } else if (index % 3 == 2) {
                        index += 18;
                    }
                } else if (index % 3 == 2) {
                    if (parseInt(index / 9) == 0) {
                        index += 18;
                    } else if (parseInt(index / 9) == 1) {
                        index += 8;
                    } else if (parseInt(index / 9) == 2) {
                        index -= 2;
                    }
                } else if (parseInt(index / 9) == 2) {
                    if (index % 3 == 2) {
                        index -= 2;
                    } else if (index % 3 == 1) {
                        index -= 10;
                    } else if (index % 3 == 0) {
                        index -= 18;
                    }
                } else if (index % 3 == 0) {
                    if (parseInt(index / 9) == 2) {
                        index -= 18;
                    } else if (parseInt(index / 9) == 1) {
                        index -= 8;
                    } else if (parseInt(index / 9) == 0) {
                        index += 2;
                    }
                }
                rotateNum--;
            }
            let cube;
            for (let i = 0; i < cubes.length; i++) {
                if (cubes[i].cubeIndex == index + minCubeIndex) {
                    cube = cubes[i];
                }
            }
            return cube;
        }

        function getCubesByIndices(indices) {
            let arr = [];
            for (let i = 0; i < indices.length; i++) {
                arr.push(getCubeByIndex(indices[i]));
            }
            return arr;
        }

        /*
         * Function to get the vector after clockwise rotation around Y
         */
        function rotateAxisByYLine(vector, rotateNum) {
            while (rotateNum > 0) {
                if (vector.angleTo(XLine) == 0) {
                    vector = ZLineR.clone();
                } else if (vector.angleTo(ZLineR) == 0) {
                    vector = XLineR.clone();
                } else if (vector.angleTo(XLineR) == 0) {
                    vector = ZLine.clone();
                } else if (vector.angleTo(ZLine) == 0) {
                    vector = XLine.clone();
                }
                rotateNum--
            }
            return vector;
        }

        /*
         * Function to get the color of the opposite face.
         */
        function getOppositeColor(index) {
            if (index % 2 == 0 || index == 0) {
                return index + 1;
            } else {
                return index - 1;
            }
        }

        /*
         * Function to get the color index of the face with target normal.
         */
        function getFaceColorByVector(cube, vector) {
            let materials = cube.material.materials;
            let faces = cube.geometry.faces;
            let normalMatrix = cube.normalMatrix;

            /**
             * The normal of the upper face of a cube is Y-axis.
             * Self-Cord Face normal x normalMatrix = viewMatrix
             * vector x invers(viewMatrix) = World-Cord Face Normal
             */
            let viewMatrix = new THREE.Matrix4();
            viewMatrix.lookAt(camera.position, viewCenter, camera.up);
            viewMatrix.getInverse(viewMatrix);
            let tempVector = vector.clone();
            tempVector.applyMatrix4(viewMatrix);
            let angles = [];

            // No equal for float, use min instead
            for (let i = 0; i < faces.length; i++) {
                let tempNormal = faces[i].normal.clone();
                tempNormal.applyMatrix3(normalMatrix);
                angles.push(tempNormal.angleTo(tempVector));
            }
            let minIndex = min(angles).index;
            return faces[minIndex].materialIndex;
        }
        /*********************************************** End of HELPER functions ***********************************************/


        window.requestAnimFrame = (function() { // need requestAnimationFrame to refresh frame
            return window.requestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                window.webkitRequestAnimationFrame;
        })();

        // Create Renderer with given width and height.
        let $frame = document.getElementById('canvas-frame');

        function initRenderer() {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0xFFFFFF, 1.0);
            $frame.appendChild(renderer.domElement);
        }

        // Create camera. Set direction and position.
        let camera;
        let controller; // View Controller.
        let viewCenter = new THREE.Vector3(0, 0, 0);

        function initCamera() {
            camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
            camera.position.set(0, 0, 600);
            camera.up.set(0, 1, 0);
            camera.lookAt(viewCenter);
        }

        // Create Scene.
        let scene;

        function initScene() {
            scene = new THREE.Scene();
        }

        // Create ambient light.
        let light;

        function initLight() {
            light = new THREE.AmbientLight(0xfefefe);
            scene.add(light);
        }

        /**
         * Simple Rubik's Cube.
         * @param (x,y,z): the center point.
         * @apram num: the level of the cube.
         * @param len: the length of each atmoic cube component.
         * @param colors: colors of six faces.
         */
         function createRubiks(x, y, z, num, len, colors) {
            // Upper left vertice position.
            const UpLeftX = x - num / 2 * len;
            const UpLeftY = y + num / 2 * len;
            const UpLeftZ = z + num / 2 * len;
            const gray = 'rgba(25,25,25,1)';

            let cubes = [];
            for (let Z = 0; Z < num; Z++) {
                for (let Y = 0; Y < num; Y++) {
                    for (let X = 0; X < num; X++) {
                        let cubegeo = new THREE.BoxGeometry(len, len, len);
                        let materialArr = [];
                        for (let c = 0; c < colors.length; c++) {
                            let color = colors[c];
                            if (c == 0 && X != 2) color = gray;
                            if (c == 1 && X != 0) color = gray;
                            if (c == 2 && Y != 0) color = gray;
                            if (c == 3 && Y != 2) color = gray;
                            if (c == 4 && Z != 0) color = gray;
                            if (c == 5 && Z != 2) color = gray;
                            let texture = new THREE.Texture(createFace(color));
                            texture.needsUpdate = true;
                            let material = new THREE.MeshLambertMaterial({
                                map: texture
                            });
                            materialArr.push(material);
                        }
                        let cube = new THREE.Mesh(cubegeo, materialArr);

                        // Centers of atomic cube components.
                        cube.position.x = (UpLeftX + len / 2) + X * len;
                        cube.position.y = (UpLeftY - len / 2) - Y * len;
                        cube.position.z = (UpLeftZ - len / 2) - Z * len;
                        cubes.push(cube)
                    }
                }
            }
            return cubes;
        }

        // Function to create texture for a face of the atmoic cube on canvas.
        function createFace(rgbaColor) {
            let canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            let context = canvas.getContext('2d');
            if (context) {
                // Background: 256*256 square.
                context.fillStyle = 'rgba(0,0,0,1)';
                context.fillRect(0, 0, 256, 256);
                // Inner colored context: 224*224 rounded square with 16px padding. 
                context.rect(16, 16, 224, 224);
                context.lineJoin = 'round';
                context.lineWidth = 16;
                context.fillStyle = rgbaColor;
                context.strokeStyle = rgbaColor;
                context.stroke();
                context.fill();
            } else {
                alert('The browser does not support viewing this Canvas.\n');
            }
            return canvas;
        }

        // Create objects in scene.
        let cubes

        function initObject() {
            // Create simple cube.
            cubes = createRubiks(cubeParams.x, cubeParams.y, cubeParams.z, cubeParams.num, cubeParams.len, cubeParams.colors);
            let ids = [];
            for (let i = 0; i < cubes.length; i++) {
                let item = cubes[i];
                // console.log(item);
                /**
                 * Since we are using item.id to select moving items, we need to set an extra dynamic cubeIndex.
                 * Update cubeIndex after rotation according to the init status.
                 */
                initStatus.push({
                    x: item.position.x,
                    y: item.position.y,
                    z: item.position.z,
                    cubeIndex: item.id
                });
                item.cubeIndex = item.id;
                ids.push(item.id);
                scene.add(cubes[i]);
            }
            minCubeIndex = min(ids).value;

            // Create transprent square for raycasting.
            let cubegeo = new THREE.BoxGeometry(150, 150, 150);
            let hex = 0x000000;
            for (let i = 0; i < cubegeo.faces.length; i++) {
                cubegeo.faces[i].color.setHex(hex);
            }
            let cubemat = new THREE.MeshBasicMaterial({
                vertexColors: THREE.FaceColors,
                opacity: 0,
                transparent: true
            });
            let cube = new THREE.Mesh(cubegeo, cubemat);
            cube.cubeType = 'coverCube';
            scene.add(cube);
        }

        // Render scene.
        function render() {
            renderer.clear();
            renderer.render(scene, camera);
            window.requestAnimFrame(render);
        }

        // Main function.
        function threeStart() {
            initRenderer();
            initCamera();
            initScene();
            initLight();
            initObject();
            render();

            // Mouse event listener.
            renderer.domElement.addEventListener('mousedown', startCubeRotation, false);
            renderer.domElement.addEventListener('mousemove', rotateCube, false);
            renderer.domElement.addEventListener('mouseup', stopCubeRotation, false);

            // View controller.
            controller = new THREE.OrbitControls(camera, renderer.domElement);
            controller.target = new THREE.Vector3(0, 0, 0); // Set controller point.

            // Naive Solver.
            let $naiveSolverButton = document.querySelector('#naiveSolverButton');
            $naiveSolverButton.addEventListener('click', function() {
                naiveSolver();
            }, false);

            // Shuffle.
            let $shuffleButton = document.querySelector('#shuffleButton');
            $shuffleButton.addEventListener('click', function() {
                shuffle();
            }, false);
        }

        // Get intersection point and the face it belongs to. And the normal vector of this face.
        function getIntersects(event) {
            mouse.x = (event.clientX / width) * 2 - 1;
            mouse.y = -(event.clientY / height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Use Raycaster to get the first element among intersected items.
            let intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length) {
                try {
                    if (intersects[0].object.cubeType === 'coverCube') {
                        intersect = intersects[1];
                        normalize = intersects[0].face.normal;
                    } else {
                        intersect = intersects[0];
                        normalize = intersects[1].face.normal;
                    }
                } catch (err) {
                }
            }
        }

        function startCubeRotation(event) {
            getIntersects(event);
            // Start cube rotation only when the cube is not rotating and we catch the intersect.
            if (!isRotating && intersect) {
                startPoint = intersect.point; // set starting point of rotation.
                controller.enabled = false;   // ignore the controller when we are rotating the cube.
            } else {
                controller.enabled = true; 
            }
        }

        // Cube rotation given mouse event.
        function rotateCube(event) {
            getIntersects(event);
            if (intersect) {
                if (!isRotating && startPoint) {
                    movePoint = intersect.point;
                    if (!movePoint.equals(startPoint)) { // Rotated.
                        let sub = movePoint.sub(startPoint); // get rotation vector.
                        rotateMove(intersect.object, sub);
                    }
                }
            }
            event.preventDefault();
        }

        function rotateMove(target, vector, callback) {
            isRotating = true;
            let direction = getDirection(vector); // calculate rotation direction.
            let elements = getCubesToRotate(target, direction);
            window.requestAnimFrame(function(timestamp) {
                rotateAnimation(elements, direction, timestamp, 0, null, callback);
            });
        }

        function stopCubeRotation() {
            intersect = null;
            startPoint = null;
        }

        

        function rotateAroundWorldY(obj, rad) {
            let x0 = obj.position.x;
            let z0 = obj.position.z;
            let q = new THREE.Quaternion();
            q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rad);
            obj.quaternion.premultiply(q);
            // obj.rotateY(rad);
            obj.position.x = Math.cos(rad) * x0 + Math.sin(rad) * z0;
            obj.position.z = Math.cos(rad) * z0 - Math.sin(rad) * x0;
        }

        function rotateAroundWorldZ(obj, rad) {
            let x0 = obj.position.x;
            let y0 = obj.position.y;
            let q = new THREE.Quaternion();
            q.setFromAxisAngle(new THREE.Vector3(0, 0, 1), rad);
            obj.quaternion.premultiply(q);
            // obj.rotateZ(rad);
            obj.position.x = Math.cos(rad) * x0 - Math.sin(rad) * y0;
            obj.position.y = Math.cos(rad) * y0 + Math.sin(rad) * x0;
        }

        function rotateAroundWorldX(obj, rad) {
            let y0 = obj.position.y;
            let z0 = obj.position.z;
            let q = new THREE.Quaternion();
            q.setFromAxisAngle(new THREE.Vector3(1, 0, 0), rad);
            obj.quaternion.premultiply(q);
            // obj.rotateX(rad);
            obj.position.y = Math.cos(rad) * y0 - Math.sin(rad) * z0;
            obj.position.z = Math.cos(rad) * z0 + Math.sin(rad) * y0;
        }

        /**
         * Function to animate rotation.
         */
        function rotateAnimation(elements, direction, currentstamp, startstamp, laststamp, callback) {
            let totalTime = 100;
            let isLastRotateFrame = false;
            if (startstamp === 0) {
                startstamp = currentstamp;
                laststamp = currentstamp;
            }
            if (currentstamp - startstamp >= totalTime) { // stop animation.
                currentstamp = startstamp + totalTime;
                isLastRotateFrame = true;
            }
            switch (direction) {
                // Clockwise around X.
                case 1:
                    for (let i = 0; i < elements.length; i++) {
                        rotateAroundWorldX(elements[i], 90 * Math.PI / 180 * (currentstamp - laststamp) / totalTime);
                    }
                    break;
                // Counter-Clockwise around X.
                case 2:
                    for (let i = 0; i < elements.length; i++) {
                        rotateAroundWorldX(elements[i], -90 * Math.PI / 180 * (currentstamp - laststamp) / totalTime);
                    }
                    break;
                // Clockwise around Y.
                case 3:
                    for (let i = 0; i < elements.length; i++) {
                        rotateAroundWorldY(elements[i], -90 * Math.PI / 180 * (currentstamp - laststamp) / totalTime);
                    }
                    break;
                // Counter-Clockwise around Y.
                case 4:
                    for (let i = 0; i < elements.length; i++) {
                        rotateAroundWorldY(elements[i], 90 * Math.PI / 180 * (currentstamp - laststamp) / totalTime);
                    }
                    break;
                // Clockwise around Z.
                case 5:
                    for (let i = 0; i < elements.length; i++) {
                        rotateAroundWorldZ(elements[i], -90 * Math.PI / 180 * (currentstamp - laststamp) / totalTime);
                    }
                    break;
                // Counter-Clockwise around Z.
                case 6:
                    for (let i = 0; i < elements.length; i++) {
                        rotateAroundWorldZ(elements[i], 90 * Math.PI / 180 * (currentstamp - laststamp) / totalTime);
                    }
                    break;
                default:
                    break;
            }
            if(!isLastRotateFrame) {
                window.requestAnimFrame(function(timestamp) {
                    rotateAnimation(elements, direction, timestamp, startstamp, currentstamp, callback);
                });
            } else {
                isRotating = false;
                startPoint = null;
                updateCubeIndex(elements);
                if(callback) {
                    callback();
                } else {
                    if(isAutoSolver) {
                        switch(currentStep) {
                            case 1:
                                step1();
                                break;
                            case 2:
                                step2();
                                break;
                            case 3:
                                step3();
                                break;
                            case 4:
                                step4();
                                break;
                            case 5:
                                step5();
                                break;
                            case 6:
                                step6();
                                break;
                            case 7:
                                step7();
                                break;
                            case 8:
                                step8();
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        }

        function updateCubeIndex(elements) {
            for (let i = 0; i < elements.length; i++) {
                let temp1 = elements[i];
                for (let j = 0; j < initStatus.length; j++) {
                    let temp2 = initStatus[j];
                    if (Math.abs(temp1.position.x - temp2.x) <= cubeParams.len / 2 &&
                        Math.abs(temp1.position.y - temp2.y) <= cubeParams.len / 2 &&
                        Math.abs(temp1.position.z - temp2.z) <= cubeParams.len / 2) {
                        temp1.cubeIndex = temp2.cubeIndex;
                        temp1.skipNext = false;
                        break;
                    }
                }
            }
        }

        // Function to get all atomic cubes that should be rotated
        function getCubesToRotate(target, direction) {
            let targetId = target.cubeIndex - minCubeIndex;
            const Z_Offset = parseInt(targetId / 9);
            const Y_Offset = parseInt((targetId % 9) / 3);
            const X_Offset = parseInt((targetId % 9) % 3);

            let boxs = [];

            switch (direction) {
                // Around X.
                case 1: case 2:
                    for (let i = 0; i < cubes.length; i++) {
                        let tempId = cubes[i].cubeIndex - minCubeIndex;
                        if (X_Offset === tempId % 9 % 3) {
                            boxs.push(cubes[i]);
                        }
                    }
                    break;
                // Around Y.
                case 3: case 4:
                    for (let i = 0; i < cubes.length; i++) {
                        let tempId = cubes[i].cubeIndex - minCubeIndex;
                        if (Y_Offset === parseInt(tempId % 9 / 3)) {
                            boxs.push(cubes[i]);
                        }
                    }
                    break;
                // Around Z.
                case 5: case 6:
                    for (let i = 0; i < cubes.length; i++) {
                        let tempId = cubes[i].cubeIndex - minCubeIndex;
                        if (Z_Offset === parseInt(tempId / 9)) {
                            boxs.push(cubes[i]);
                        }
                    }
                    break;
                default:
                    break;
            }
            return boxs;
        }

        // Function to get rotation direction.
        function getDirection(vector3) {
            // calculate angle of vector to x,y,z-axis.
            const XAngle = vector3.angleTo(XLine);
            const XAngleR = vector3.angleTo(XLineR);
            const YAngle = vector3.angleTo(YLine);
            const YAngleR = vector3.angleTo(YLineR);
            const ZAngle = vector3.angleTo(ZLine);
            const ZAngleR = vector3.angleTo(ZLineR);
            const minAngle = min([XAngle, XAngleR, YAngle, YAngleR, ZAngle, ZAngleR]).value;
            
            let direction;
            switch (minAngle) {
                case XAngle: // Rotate 90 degrees to the positive X.
                    if (normalize.equals(YLine)) {
                        direction = 5; // Clockwise around Z.
                    } else if (normalize.equals(YLineR)) {
                        direction = 6; // Counter-Clockwise around Z.
                    } else if (normalize.equals(ZLine)) {
                        direction = 4; // Counter-Clockwise around Y.
                    } else {
                        direction = 3; // Clockwise around Y.
                    }
                    break;
                case XAngleR: // Rotate 90 degrees to the negative X.
                    if (normalize.equals(YLine)) {
                        direction = 6; // Counter-Clockwise around Z.
                    } else if (normalize.equals(YLineR)) {
                        direction = 5; // Clockwise around Z.
                    } else if (normalize.equals(ZLine)) {
                        direction = 3; // Clockwise around Y.
                    } else {
                        direction = 4; // Counter-Clockwise around Y.
                    }
                    break;
                case YAngle: // Rotate 90 degrees to the positive Y.
                    if (normalize.equals(ZLine)) {
                        direction = 2; // Counter-Clockwise around X.
                    } else if (normalize.equals(ZLineR)) {
                        direction = 1; // Clockwise around X.
                    } else if (normalize.equals(XLine)) {
                        direction = 6; // Counter-Clockwise around Z.
                    } else {
                        direction = 5; // Clockwise around Z.
                    }
                    break;
                case YAngleR: // Rotate 90 degrees to the negative Y.
                    if (normalize.equals(ZLine)) {
                        direction = 1; // Clockwise around X.
                    } else if (normalize.equals(ZLineR)) {
                        direction = 2; // Counter-Clockwise around X.
                    } else if (normalize.equals(XLine)) {
                        direction = 5; // Clockwise around Z.
                    } else {
                        direction = 6; // Counter-Clockwise around Z.
                    }
                    break;
                case ZAngle: // Rotate 90 degrees to the positive Z.
                    if (normalize.equals(YLine)) {
                        direction = 1; // Clockwise around X.
                    } else if (normalize.equals(YLineR)) {
                        direction = 2; // Counter-Clockwise around X.
                    } else if (normalize.equals(XLine)) {
                        direction = 3; // Clockwise around Y.
                    } else {
                        direction = 4; // Counter-Clockwise around Y.
                    }
                    break;
                case ZAngleR: // Rotate 90 degrees to the negative Z.
                    if (normalize.equals(YLine)) {
                        direction = 2; // Counter-Clockwise around X.
                    } else if (normalize.equals(YLineR)) {
                        direction = 1; // Clockwise around X.
                    } else if (normalize.equals(XLine)) {
                        direction = 4; // Counter-Clockwise around Y.
                    } else {
                        direction = 3; // Clockwise around Y.
                    }
                    break;
                default:
                    break;
            }
            // console.log(direction);
            return direction;
        }

        // get min element in an array.
        function min(arr) {
            let min = arr[0];
            let index = 0;
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] < min) {
                    min = arr[i];
                    index = i;
                }
            }
            return {index: index, value: min};
        }
    </script>
</body>

</html>